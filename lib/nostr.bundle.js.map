{
  "version": 3,
  "sources": ["../index.ts", "../keygen.ts", "../node_modules/@noble/ed25519/lib/esm/index.js", "../node_modules/@noble/hashes/src/hkdf.ts", "../node_modules/@noble/hashes/src/_assert.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/cryptoBrowser.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../node_modules/@noble/hashes/src/_sha2.ts", "../node_modules/@noble/secp256k1/lib/esm/index.js"],
  "sourcesContent": ["export * as keygen from './keygen'\n\n// monkey patch secp256k1\nimport * as secp256k1 from '@noble/secp256k1'\nimport {hmac} from '@noble/hashes/hmac'\nimport {sha256} from '@noble/hashes/sha256'\nsecp256k1.utils.hmacSha256Sync = (key, ...msgs) =>\n  hmac(sha256, key, secp256k1.utils.concatBytes(...msgs))\nsecp256k1.utils.sha256Sync = (...msgs) =>\n  sha256(secp256k1.utils.concatBytes(...msgs))\n", "import * as ed25519 from '@noble/ed25519'\nimport {hkdf} from '@noble/hashes/hkdf'\nimport {sha256} from '@noble/hashes/sha256'\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nfunction Stringify(arg: any) {\n  return JSON.parse(JSON.stringify(arg, (key, value) =>\n      typeof value === 'bigint'\n          ? value.toString()\n          : value // return everything else unchanged\n  ));\n}\n\n/**\n *\n * @param username key identifier\n * @param caip10 CAIP identifier for the blockchain account\n * @param sig Deterministic signature from X-wallet provider\n * @param password Optional password\n * @returns Deterministic private key as hex string\n */\nexport async function ed25519Keygen(\n  username: string,\n  caip10: string,\n  sig: string,\n  password: string | undefined\n): Promise<[bigint, any]> {\n  if (sig.length < 64)\n    throw new Error('Signature too short; length should be 65 bytes')\n  let inputKey = sha256(\n    ed25519.utils.hexToBytes(\n      sig.toLowerCase().startsWith('0x') ? sig.slice(2) : sig\n    )\n  )\n  let info = `${caip10}:${username}`\n  let salt = sha256(`${info}:${password ? password : ''}:${sig.slice(-64)}`)\n  let hashKey = hkdf(sha256, inputKey, salt, info, 42)\n  let privateKey = ed25519.utils.hashToPrivateScalar(hashKey)\n  let publicKey = await ed25519.getPublicKey(privateKey)\n  return [Stringify(privateKey), ed25519.utils.bytesToHex(publicKey)]\n}\n\n", "/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _255n = BigInt(255);\nconst CURVE_ORDER = _2n ** BigInt(252) + BigInt('27742317777372353535851937790883648493');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: _2n ** _255n - BigInt(19),\n    l: CURVE_ORDER,\n    n: CURVE_ORDER,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexport { CURVE };\nconst MAX_256B = _2n ** BigInt(256);\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(_2n * mod(Z1 ** _2n));\n        const D = mod(a * A);\n        const E = mod(mod((X1 + Y1) ** _2n) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** _2n));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= MAX_256B)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & (_2n ** _255n - _1n));\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, MAX_256B))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexport const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        x_3 = mod((DA + CB) ** _2n);\n        z_3 = mod(x_1 * (DA - CB) ** _2n);\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n", "import assert from './_assert.js';\nimport { CHash, Input, toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input) {\n  assert.hash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32) {\n  assert.hash(hash);\n  assert.number(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n) => expand(hash, extract(hash, ikm, salt), info, length);\n", "export function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nexport function bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nexport function bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nexport function hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nexport function exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexport function output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output,\n};\n\nexport default assert;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a: Uint8Array): string {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\n\nexport type Input = Uint8Array | string;\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (!arrays.every((a) => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  // Cleanup internal state. Not '.clean' because instance is not usable after that.\n  // Clean usually resets instance to initial state, but it is not possible for keyed hashes if key is consumed into state.\n  // NOTE: if digest is not consumed by user, user need manually call '.destroy' if zeroing is required\n  abstract destroy(): void;\n  // Unsafe because doesn't check if \"to\" is correct. Can be used as clone() if no opts passed.\n  // Why cloneInto instead of clone? Mostly performance (same as _digestInto), but also has nice property: it reuses instance\n  // which means all internal buffers is overwritten, which also causes overwrite buffer which used for digest (in some cases).\n  // We don't provide any guarantees about cleanup (it is impossible to!), so should be enough for now.\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashConstructor: () => Hash<T>) {\n  const hashC = (message: Input): Uint8Array => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto.web) {\n    return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto.node) {\n    return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}\n", "// Global symbol available in browsers only\ndeclare const self: Record<string, any> | undefined;\nexport const crypto: { node?: any; web?: any } = {\n  node: undefined,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n", "import assert from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nclass HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assert.hash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new TypeError('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assert.exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\nexport const sha224 = wrapConstructor(() => new SHA224());\n", "import assert from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    assert.exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst ENDO = {\n    a1: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),\n    b1: -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),\n    a2: BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),\n    b2: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),\n    POW_2_128: BigInt('0x100000000000000000000000000000000'),\n};\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const { a1, b1, a2, b2, POW_2_128 } = ENDO;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],
  "mappings": "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",
  "names": ["bytes", "bytes", "number", "hash", "hash", "hash", "crypto", "hexes", "hash", "hash", "HMAC", "isLE", "nodeCrypto", "_0n", "_1n", "_2n", "CURVE", "CURVE", "mod", "_0n", "Point", "_1n", "invertBatch", "_2n", "normalizeScalar", "d", "pointPrecomputes", "invert", "bytes", "ensureBytes", "hexToBytes", "bytesToHex", "concatBytes", "hexes", "pow2", "number", "hash", "_0n", "CURVE", "Point", "crypto", "nodeCrypto", "utils", "bytesToHex", "hexToBytes", "concatBytes", "mod", "invert", "hash", "ensureBytes", "CURVE", "_1n", "crypto", "Point", "utils"]
}
